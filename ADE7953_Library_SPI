'''
 ADE7953.py - Example library for operating the ADE7953 Single-Phase AC Line measurement IC over SPI for Arduino Uno
  Created by Umar Kazmi, Crystal Lai, and Michael J. Klopfer, Ph.D.
  January 23, 2017 - 0.1 (pre-release)
  May 3, 2018 - v6.2 (current version) - by MJK
  Verified for compatibility with Arduino Uno and Espressif ESP8266, please see README about ESP32 compatibility.
  University of California, Irvine - California Plug Load Research Center (CalPlug)
  Copyright: The Regents of the University of California
  Released into the public domain with Share-alike licensing.
  Be decent: if our work helped you, then please reference/acknowledge this project and its authors in your work!

  Note: Please refer to the Analog Devices ADE7953 datasheet - much of this library was based directly on the statements and methods provided in it!  Their authors get paid, trust them over us!
'''
# Debug Control:
#  ADE7953_VERBOSE_DEBUG #This line turns on verbose debug via serial monitor (Normally off or #'ed).  Use sparingly and in a test program to debug operation!  Turning this on can take a lot of memory and the delay from USB # printing out every statement is taxing temporally!  This is non-specific and for all functions, beware, it's a lot of output!  Reported bytes are in HEX

# ******************************************************************************************


# *****************ADE7953 Register Value Constants*****************#
# The  used to save space where functions are not invoked - list of full general commands for ADE7953, not all implemented in current code - put in place as prep for potential extended development.

# 8-bit Registers
SAGCYC_8 = 0x000 # SAGCYC, (R/W) Default: 0x00, Unsigned, Sag lines Cycle
DISNOLOAD_8 = 0x001 # DISNOLOAD, (R/W) Default: 0x00, Unsigned, No-load detection disable*
LCYCMODE_8 = 0x004 # LCYCMODE, (R/W) Default: 0x40, Unsigned, Line cycle accumulation mode configuration **
PGA_V_8 = 0x007 # PGA_V, (R/W) Default: 0x00, Unsigned, Voltage channel gain configuration (Bits[2:0])
PGA_IA_8 = 0x008 # PGA_IA, (R/W) Default: 0x00, Unsigned, Current Channel A gain configuration (Bits[2:0])
PGA_IB_8 = 0x009 # PGA_IB, (R/W) Default: 0x00, Unsigned, Current Channel B gain configuration (Bits[2:0])
WRITE_PROTECT_8 = 0x040 # WRITE_PROTECT, (R/W) Default: 0x00, Unsigned, Write protection bits (Bits[2:0])
LAST_OP_8 = 0x0FD # LAST_OP, (R/W) Default: 0x00, Unsigned, Contains the type (read or write) of the last successful communication (0x35 read 0xCA = write)
LAST_RWDATA_8 = 0x0FF # LAST_RWDATA_8, (R/W) Default: 0x00, Unsigned, Contains the data from the last successful 8-bit register communication
Version_8 = 0x702 # Version, (R/W) Default: N/A, Unsigned, Contains the silicon version number
EX_REF_8 = 0x800 # EX_REF, (R/W) Default: 0x00, Unsigned, Reference input configuration:0 = internal 1 = external

# *DISNOLOAD register
# **LCYCMODE register


# 16-bit Registers
ZXTOUT_16 = 0x100 # ZXTOUT, (R/W) Default:0xFFFF, Unsigned,Zero-crossing timeout
LINECYC_16 = 0x101 # LINCYC, (R/W) Default:0x0000, Unsigned,Number of half line cycles for line cycle energy accumulation mode
CONFIG_16 = 0x102 # CONFIG, (R/W) Default:0x8004, Unsigned,Configuration register***
CF1DEN_16 = 0x103 # CF1DEN, (R/W) Default:0x003F, Unsigned,CF1 frequency divider denominator. When modifying this register, two sequential write operations must be performed to ensure that the write is successful.
CF2DEN_16 = 0x104 # CF2DEN, (R/W) Default:0x003F, Unsigned,CF2 frequency divider denominator. When modifying this register, two sequential write operations must be performed to ensure that the write is successful.
CFMODE_16 = 0x107 # CFMODE, (R/W) Default:0x0300, Unsigned, CF output selection */
PHCALA_16 = 0x108 # PHCALA, (R/W) Default:0x0000, Signed,Phase calibration register (Current Channel A). This register is in sign magnitude format.
PHCALB_16 = 0x109 # PHCALB, (R/W) Default:0x0000, Signed,Phase calibration register (Current Channel B). This register is in sign magnitude format.
PFA_16 = 0x10A # PFA, (R) Default:0x0000, Signed,Power factor (Current Channel A)
PFB_16 = 0x10B # PFB, (R) Default:0x0000, Signed,Power factor (Current Channel B)
ANGLE_A_16 = 0x10C # ANGLE_A, (R) Default:0x0000, Signed,Angle between the voltage input and the Current Channel A input
ANGLE_B_16 = 0x10D # ANGLE_B, (R) Default:0x0000, Signed,Angle between the voltage input and the Current Channel B input
Period_16 = 0x10E # Period, (R) Default:0x0000, Unsigned, Period register
ALT_OUTPUT_16 = 0x110 # ALT_OUTPUT, (R/W) Default:0x0000, Unsigned,Alternative output functions**/
LAST_ADD_16 = 0x1FE # LAST_ADD, (R) Default:0x0000, Unsigned, Contains the address of the last successful communication
LAST_RWDATA_16 = 0x1FF # LAST_RWDATA_16, (R) Default:0x0000, Unsigned,Contains the data from the last successful 16-bit register communication
Reserved_16 = 0x120 # Reserved, (R/W) Default:0x0000, Unsigned,This register should be set to 30h to meet the performance specified in Table 1. To modify this register, it must be unlocked by setting Register Address 0xFE to 0xAD immediately prior. (16 bit)


# *** CONFIG register
# */ CFMODE register
# **/ALT_OUTPUT register


# 24-bit and 32-bit registers
SAGLVL_24 = 0x200 # SAGLVL, (R/W) Default: 0x000000, Unsigned, Sag Voltage Level (24 bit)
SAGLVL_32 = 0x300 # SAGLVL, (R/W) Default: 0x000000, Unsigned, Sag Voltage Level (32 bit)
ACCMODE_24 = 0x201 # ACCMODE, (R/W) Default:0x000000, Unsigned, Accumulation mode(24 bit)
ACCMODE_32 = 0x301 # ACCMODE, (R/W) Default: 0x000000, Unsigned, Accumulation mode(32 bit)
AP_NOLOAD_24 = 0x203 # AP_NOLOAD, (R/W) Default: 0x00E419, Unsigned,Active power no-load level(24 bit)
AP_NOLOAD_32 = 0x303 # AP_NOLOAD, (R/W) Default: 0x00E419, Unsigned,Active power no-load level(32 bit)
VAR_NOLOAD_24 = 0x204 # VAR_NOLOAD, (R/W) Default: 0x000000, Unsigned,Reactive power no-load level(24 bit)
VAR_NOLOAD_32 = 0x304 # VAR_NOLOAD, (R/W) Default: 0x000000, Unsigned,Reactive power no-load level(32 bit)
VA_NOLOAD_24 = 0x205 # VA_NOLOAD, (R/W) Default: 0x000000, Unsigned,Apparent power no-load level(24 bit)
VA_NOLOAD_32 = 0x305 # VA_NOLOAD, (R/W) Default: 0x000000, Unsigned,Apparent power no-load level(32 bit)
AVA_24 = 0x210 # AVA, (R) Default: 0x000000, Signed,Instantaneous apparent power (Current Channel A)(24 bit)
AVA_32 = 0x310 # AVA, (R) Default: 0x000000, Signed,Instantaneous apparent power (Current Channel A)(32 bit)
BVA_24 = 0x211 # BVA, (R) Default: 0x000000, Signed,Instantaneous apparent power (Current Channel B)(24 bit)
BVA_32 = 0x311 # BVA, (R) Default: 0x000000, Signed,Instantaneous apparent power (Current Channel B)(32 bit)
AWATT_24 = 0x212 # AWATT, (R) Default: 0x000000, Signed,Instantaneous active power (Current Channel A)(24 bit)
AWATT_32 = 0x312 # AWATT, (R) Default: 0x000000, Signed,Instantaneous active power (Current Channel A)(32 bit)
BWATT_24 = 0x213 # BWATT, (R) Default: 0x000000, Signed,Instantaneous active power (Current Channel B)(24 bit)
BWATT_32 = 0x313 # BWATT, (R) Default: 0x000000, Signed,Instantaneous active power (Current Channel B)(32 bit)
AVAR_24 = 0x214 # AVAR, (R) Default: 0x000000, Signed,Instantaneous reactive power (Current Channel A)(24 bit)
AVAR_32 = 0x314 # AVAR, (R) Default: 0x000000, Signed,Instantaneous reactive power (Current Channel A)(32 bit)
BVAR_24 = 0x215 # BVAR, (R) Default: 0x000000, Signed,Instantaneous reactive power (Current Channel B)(24 bit)
BVAR_32 = 0x315 # BVAR, (R) Default: 0x000000, Signed,Instantaneous reactive power (Current Channel B)(32 bit)
IA_24 = 0x216 # IA, (R) Default: 0x000000, Signed, Instantaneous current (Current Channel A)(24 bit)
IA_32 = 0x316 # IA, (R) Default: 0x000000, Signed,Instantaneous current (Current Channel A)(32 bit)
IB_24 = 0x217 # IB, (R) Default: 0x000000, Signed,Instantaneous current (Current Channel B)(24 bit)
IB_32 = 0x317 # IB, (R) Default: 0x000000, Signed,Instantaneous current (Current Channel B)(32 bit)
V_24 = 0x218 # V, (R) Default: 0x000000, Signed,Instantaneous voltage (voltage channel)(24 bit)
V_32 = 0x318 # V, (R) Default: 0x000000, Signed,Instantaneous voltage (voltage channel)(32 bit)
IRMSA_24 = 0x21A # IRMSA, (R) Default: 0x000000, Unsigned,IRMS register (Current Channel A)(24 bit)
IRMSA_32 = 0x31A # IRMSA, (R) Default: 0x000000, Unsigned,IRMS register (Current Channel A)(32 bit)
IRMSB_24 = 0x21B # IRMSB, (R) Default: 0x000000, Unsigned,IRMS register (Current Channel B)(24 bit)
IRMSB_32 = 0x31B # IRMSB, (R) Default: 0x000000, Unsigned,IRMS register (Current Channel B)(32 bit)
VRMS_24 = 0x21C # VRMS, (R) Default: 0x000000, Unsigned, VRMS register (24 bit)
VRMS_32 = 0x31C # VRMS, (R) Default: 0x000000, Unsigned, VRMS register (32 bit)

AENERGYA_24 = 0x21E # AENERYGA, (R) Default: 0x000000, Signed,Active energy (Current Channel A) (24 bit)
AENERGYA_32 = 0x31E # AENERYGA, (R) Default: 0x000000, Signed,Active energy (Current Channel A)(32 bit)
AENERGYB_24 = 0x21F # AENERYGB, (R) Default: 0x000000, Signed,Active energy (Current Channel B)(24 bit)
AENERGYB_32 = 0x31F # AENERYGB, (R) Default: 0x000000, Signed,Active energy (Current Channel B)(32 bit)
RENERGYA_24 = 0x220 # RENERGYA, (R) Default: 0x000000, Signed,Reactive energy (Current Channel A) (24 bit)
RENERGYA_32 = 0x320 # RENERGYA, (R) Default: 0x000000, Signed,Reactive energy (Current Channel A)(32 bit)
RENERGYB_24 = 0x221 # RENERGYB, (R) Default: 0x000000, Signed,Reactive energy (Current Channel B) (24 bit)
RENERGYB_32 = 0x321 # RENERGYB, (R) Default: 0x000000, Signed,Reactive energy (Current Channel B)(32 bit)
APENERGYA_24 = 0x222 # APENERGYA, (R) Default: 0x000000, Signed,Apparent energy (Current Channel A) (24 bit)
APENERGYA_32 = 0x322 # APENERGYA, (R) Default: 0x000000, Signed,Apparent energy (Current Channel A)(32 bit)
APENERGYB_24 = 0x223 # APENERGYB, (R) Default: 0x000000, Signed,Apparent energy (Current Channel B)(24 bit)
APENERGYB_32 = 0x323 # APENERGYB, (R) Default: 0x000000, Signed,Apparent energy (Current Channel B)(32 bit)
OVLVL_24 = 0x224 # OVLVL, (R/W) Default: 0xFFFFFF, Unsigned, Overvoltage level(24 bit)
OVLVL_32 = 0x324 # OVLVL, (R/W) Default: 0xFFFFFF, Unsigned,Overvoltage level(32 bit)

OILVL_24 = 0x225 # OILVL, (R/W) Default: 0xFFFFFF,Unsigned, Overcurrent level (24 bit)
OILVL_32 = 0x325 # OILVL, (R/W) Default: 0xFFFFFF, Unsigned,Overcurrent level (32 bit)

VPEAK_24 = 0x226 # VPEAK, (R) Default: 0x000000, Unsigned, Voltage channel peak(24 bit)
VPEAK_32 = 0x326 # VPEAK, (R) Default: 0x000000, Unsigned,Voltage channel peak(32 bit)
RSTVPEAK_24 =0x227 # RSTVPEAK, (R) Default: 0x000000, Unsigned,Read voltage peak with reset (24 bit)
RSTVPEAK_32 =0x327 # RSTVPEAK, (R) Default: 0x000000, Unsigned,Read voltage peak with reset(32 bit)
IAPEAK_24 = 0x228 # IAPEAK, (R) Default: 0x000000, Unsigned,Current Channel A peak(24 bit)
IAPEAK_32 = 0x328 # IAPEAK, (R) Default: 0x000000, Unsigned,Current Channel A peak(32 bit)
RSTIAPEAK_24 = 0x229 # RSTIAPEAK, (R) Default: 0x000000, Unsigned, Read Current Channel A peak with reset(24 bit)
RSTIAPEAK_32 = 0x329 # RSTIAPEAK, (R) Default: 0x000000, Unsigned,Read Current Channel A peak with reset(32 bit)
IBPEAK_24 = 0x22A # IBPEAK, (R) Default: 0x000000, Unsigned, Current Channel B peak(24 bit)
IBPEAK_32 = 0x32A # IBPEAK, (R) Default: 0x000000, Unsigned,Current Channel B peak(32 bit)
RSTIBPEAK_24 = 0x22B # RSTIBPEAK, (R) Default: 0x000000, Unsigned, Read Current Channel B peak with reset(24 bit)
RSTIBPEAK_32 = 0x32B # RSTIBPEAK, (R) Default: 0x000000, Unsigned,Read Current Channel B peak with reset(32 bit)
IRQENA_24 = 0x22C # IRQENA, (R/W) Default: 0x100000, Unsigned,Interrupt enable (Current Channel A (24 bit)
IRQENA_32 = 0x32C # IRQENA, (R/W) Default: 0x100000, Unsigned,Interrupt enable (Current Channel A(32 bit)
IRQSTATA_24 = 0x22D # IRQSTATA, (R) Default: 0x000000, Unsigned, Interrupt status (Current Channel A(24 bit)
IRQSTATA_32 = 0x32D # IRQSTATA, (R) Default: 0x000000, Unsigned,Interrupt status (Current Channel A(32 bit)
RSTIRQSTATA_24 = 0x22E # RSTIRQSTATA, (R) Default: 0x000000, Unsigned, Reset interrupt status (Current Channel A) (24 bit)
RSTIRQSTATA_32 = 0x32E # RSTIRQSTATA, (R) Default: 0x000000, Unsigned,Reset interrupt status (Current Channel A)(32 bit)
IRQENB_24 = 0x22F # IRQENB, (R/W) Default: 0x000000, Unsigned,Interrupt enable (Current Channel B (24 bit)
IRQENB_32 = 0x32F # IRQENB, (R/W) Default: 0x000000, Unsigned,Interrupt enable (Current Channel B (32 bit)
IRQSTATB_24 = 0x230 # IRQSTATB, (R) Default: 0x000000, Unsigned, Interrupt status (Current Channel B(24 bit)
IRQSTATB_32 = 0x330 # IRQSTATB, (R) Default: 0x000000, Unsigned,Interrupt status (Current Channel B(32 bit)
RSTIRQSTATB_24 = 0x231 # RSTIRQSTATB, (R) Default: 0x000000, Unsigned,Reset interrupt status (Current Channel B) (24 bit)
RSTIRQSTATB_32 = 0x331 # RSTIRQSTATB, (R) Default: 0x000000, Unsigned, Reset interrupt status (Current Channel B)(32 bit)
CRC_24 = 0x000 # CRC, (R) Default: 0x000000, Unsigned, Checksum(24 bit)
CRC_32 = 0x37F # CRC, (R) Default: 0xFFFFFF, Unsigned,Checksum(32 bit)
AIGAIN_24 = 0x280 # AIGAIN, (R/W) Default: 0x400000, Unsigned, Current channel gain (Current Channel A)(24 bit)
AIGAIN_32 = 0x380 # AIGAIN, (R/W) Default: 0x400000, Unsigned,Current channel gain (Current Channel A)(32 bit)
AVGAIN_24 = 0x281 # AVGAIN, (R/W) Default: 0x400000, Unsigned, Voltage channel gain(24 bit)
AVGAIN_32 = 0x381 # AVGAIN, (R/W) Default: 0x400000, Unsigned,Voltage channel gain(32 bit)
AWGAIN_24 = 0x282 # AWGAIN, (R/W) Default: 0x400000, Unsigned,Active power gain (Current Channel A)(24 bit)
AWGAIN_32 = 0x382 # AWGAIN, (R/W) Default: 0x400000, Unsigned,Active power gain (Current Channel A)(32 bit)
AVARGAIN_24 = 0x283 # AVARGAIN, (R/W) Default: 0x400000, Unsigned, Reactive power gain (Current Channel A)(24 bit)
AVARGAIN_32 = 0x383 # AVARGAIN, (R/W) Default: 0x400000, Unsigned, Reactive power gain (Current Channel A)(32 bit)
AVAGAIN_24 = 0x284 # AVAGAIN, (R/W) Default: 0x400000, Unsigned, Apparent power gain (Current Channel A) (24 bit)
AVAGAIN_32 = 0x384 # AVAGAIN, (R/W) Default: 0x400000, Unsigned,Apparent power gain (Current Channel A)(32 bit)
Reserved_24 = 0x285 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified (24 bit)
Reserved_32 = 0x385 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified(32 bit)


AIRMSOS_24 = 0x286 # AIRMSOS, (R/W) Default: 0x000000, Signed,IRMS offset (Current Channel A) (24 bit)
AIRMSOS_32 = 0x386 # AIRMSOS, (R/W) Default: 0x000000, Signed,IRMS offset (Current Channel A)(32 bit)
Reserved1_24 = 0x287 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified (24 bit)
Reserved1_32 = 0x387 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified(32 bit)

VRMSOS_24 = 0x288 # VRMSOS, (R/W) Default: 0x000000, Signed, VRMS offset(24 bit)
VRMSOS_32 = 0x388 # VRMSOS, (R/W) Default: 0x000000, Signed,VRMS offset(32 bit)
AWATTOS_24 = 0x289 # AWATTOS, (R/W) Default: 0x000000, Signed, Active power offset correction (Current Channel A)(24 bit)
AWATTOS_32 = 0x389 # AWATTOS, (R/W) Default: 0x000000, Signed,Active power offset correction (Current Channel A)(32 bit)
AVAROS_24 = 0x28A # AVAROS, (R/W) Default: 0x000000, Signed, Reactive power offset correction (Current Channel A)(24 bit)
AVAROS_32 = 0x38A # AVAROS, (R/W) Default: 0x000000, Signed, Reactive power offset correction (Current Channel A)(32 bit)
AVAOS_24 = 0x28B # AVAOS, (R/W) Default: 0x000000, Signed, Apparent power offset correction (Current Channel A(24 bit)
AVAOS_32 = 0x38B # AVAOS, (R/W) Default: 0x000000, Signed,Apparent power offset correction (Current Channel A(32 bit)
BIGAIN_24 =0x28C # BIGAIN, (R/W) Default: 0x400000, Unsigned,Current channel gain (Current Channel B) (24 bit)
BIGAIN_32 =0x38C # BIGAIN, (R/W) Default: 0x400000, Unsigned,Current channel gain (Current Channel B)(32 bit)
BVGAIN_24 =0x28D # BVGAIN, (R/W) Default: 0x400000, Unsigned, This register should not be modified(24 bit)
BVGAIN_32 =0x38D # BVGAIN, (R/W) Default: 0x400000, Unsigned,This register should not be modified(32 bit)
BWGAIN_24 =0x28E # BWGAIN, (R/W) Default: 0x400000, Unsigned, Active power gain (Current Channel B)(24 bit)
BWGAIN_32 =0x38E # BWGAIN, (R/W) Default: 0x400000, Unsigned,Active power gain (Current Channel B)(32 bit)
BVARGAIN_24 = 0x28F # BVARGAIN, (R/W) Default: 0x400000, Unsigned, Reactive power gain (Current Channel B)(24 bit)
BVARGAIN_32 = 0x38F # BVARGAIN, (R/W) Default: 0x400000, Unsigned,Reactive power gain (Current Channel B)(32 bit)
BVAGAIN_24 = 0x290 # BVAGAIN, (R/W) Default: 0x400000, Unsigned, Apparent power gain (Current Channel B)(24 bit)
BVAGAIN_32 = 0x390 # BVAGAIN, (R/W) Default: 0x400000, Unsigned,Apparent power gain (Current Channel B)(32 bit)

Reserved2_24 = 0x291 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified (24 bit)
Reserved2_32 = 0x391 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified(32 bit)

BIRMSOS_24 = 0x292 # BIRMSOS, (R/W) Default: 0x000000, Unsigned, IRMS offset (Current Channel B)(24 bit)
BIRMSOS_32 = 0x392 # BIRMSOS, (R/W) Default: 0x000000, Unsigned,IRMS offset (Current Channel B)(32 bit)

Reserved3_24 = 0x293 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified (24 bit)
Reserved3_32 = 0x393 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified(32 bit)
Reserved4_24 = 0x294 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified (24 bit)
Reserved4_32 = 0x394 # Reserved, (R/W) Default: 0x000000, Signed,This register should not be modified(32 bit)

BWATTOS_24 = 0x295 # BWATTOS, (R/W) Default: 0x000000, Unsigned, Active power offset correction (Current Channel B)(24 bit)
BWATTOS_32 = 0x395 # BWATTOS, (R/W) Default: 0x000000, Unsigned,Active power offset correction (Current Channel B)(32 bit)
BVAROS_24 = 0x296 # BVAROS, (R/W) Default: 0x000000, Unsigned,Reactive power offset correction (Current Channel B)(24 bit)
BVAROS_32 = 0x396 # BVAROS, (R/W) Default: 0x000000, Unsigned,Reactive power offset correction (Current Channel B)(32 bit)
BVAOS_24 = 0x297 # BVAOS, (R/W) Default: 0x000000, Unsigned, Apparent power offset correction (Current Channel B)(24 bit)
BVAOS_32 = 0x397 # BVAOS, (R/W) Default: 0x000000, Unsigned,Apparent power offset correction (Current Channel B)(32 bit)
LAST_RWDATA_24 = 0x2FF # LAST_RWDATA, (R) Default: 0x000000, Unsigned, Contains the data from the last successful 24-bit/32-bit register communication(24 bit)
LAST_RWDATA_32 = 0x3FF # LAST_RWDATA, (R) Default: 0x000000, Unsigned, Contains the data from the last successful 24-bit/32-bit register communication(32 bit)

'''
ADE7953 REGISTER DESCRIPTIONS

DISNOLOAD Register (Address 0x001)
Bits Bit Name Default Description
0 DIS_APNLOAD 0 1 = disable the active power no-load feature on Current Channel A and Current Channel B
1 DIS_VARNLOAD 0 1 = disable the reactive power no-load feature on Current Channel A and Current Channel B
2 DIS_VANLOAD 0 1 = disable the apparent power no-load feature on Current Channel A and Current Channel B

LCYCMODE Register (Address 0x004)
Bits Bit Name Default Description
0 ALWATT 0 0 = disable active energy line cycle accumulation mode on Current Channel A
1 = enable active energy line cycle accumulation mode on Current Channel A
1 BLWATT 0 0 = disable active energy line cycle accumulation mode on Current Channel B
1 = enable active energy line cycle accumulation mode on Current Channel B
2 ALVAR 0 0 = disable reactive energy line cycle accumulation mode on Current Channel A
1 = enable reactive energy line cycle accumulation mode on Current Channel A
3 BLVAR 0 0 = disable reactive energy line cycle accumulation mode on Current Channel B
1 = enable reactive energy line cycle accumulation mode on Current Channel B
4 ALVA 0 0 = disable apparent energy line cycle accumulation mode on Current Channel A
1 = enable apparent energy line cycle accumulation mode on Current Channel A
5 BLVA 0 0 = disable apparent energy line cycle accumulation mode on Current Channel B
1 = enable apparent energy line cycle accumulation mode on Current Channel B
6 RSTREAD 1 0 = disable read with reset for all registers
1 = enable read with reset for all registers

CONFIG Register (Address 0x102)
Bits Bit Name Default Description
0 INTENA 0 1 = integrator enable (Current Channel A)
1 INTENB 0 1 = integrator enable (Current Channel B)
2 HPFEN 1 1 = HPF enable (all channels)
3 PFMODE 0 0 = power factor is based on instantaneous powers, 1 = power factor is based on line cycle accumulation mode energies
4 REVP_CF 0 0 = REVP is updated on CF1, 1 = REVP is updated on CF2
5 REVP_PULSE 0 0 = REVP is high when reverse polarity is true, low when reverse polarity is false, 1 = REVP outputs a 1 Hz pulse when reverse polarity is true and is low when reverse polarity is false
6 ZXLPF 0 0 = ZX LPF is enabled, 1 = ZX LPF is disabled
7 SWRST 0 Setting this bit enables a software reset
8 CRC_ENABLE 0 0 = CRC is disabled, 1 = CRC is enabled
[10:9] Reserved 00 Reserved
11 ZX_I 0 0 = ZX_I is based on Current Channel A, 1 = ZX_I is based on Current Channel B
[13:12] ZX_EDGE 00 Zero-crossing interrupt edge selection
Setting               Edge Selection
00                    Interrupt is issued on both positive-going and negative-going zero crossing
01                    Interrupt is issued on negative-going zero crossing
10                    Interrupt is issued on positive-going zero crossing
11                    Interrupt is issued on both positive-going and negative-going zero crossing
14                    Reserved 0 Reserved
15                    COMM_LOCK 1 0 = communication locking feature is enabled, 1 = communication locking feature is disabled

CFMODE Register (Address 0x107)
Bits Bit Name Default Description
[3:0] CF1SEL 0000 Configuration of output signal on CF1 pin
Setting CF1 Output Signal Configuration
0000 CF1 is proportional to active power (Current Channel A)
0001 CF1 is proportional to reactive power (Current Channel A)
0010 CF1 is proportional to apparent power (Current Channel A)
0011 CF1 is proportional to IRMS (Current Channel A)
0100 CF1 is proportional to active power (Current Channel B)
0101 CF1 is proportional to reactive power (Current Channel B)
0110 CF1 is proportional to apparent power (Current Channel B)
0111 CF1 is proportional to IRMS (Current Channel B)
1000 CF1 is proportional to IRMS (Current Channel A) + IRMS (Current Channel B)
1001 CF1 is proportional to active power (Current Channel A) + active power (Current Channel B)
[7:4] CF2SEL 0000 Configuration of output signal on CF2 pin
Setting              CF2 Output Signal Configuration
0000                 CF2 is proportional to active power (Current Channel A)
0001                 CF2 is proportional to reactive power (Current Channel A)
0010                 CF2 is proportional to apparent power (Current Channel A)
0011                 CF2 is proportional to IRMS (Current Channel A)
0100                 CF2 is proportional to active power (Current Channel B)
0101                 CF2 is proportional to reactive power (Current Channel B)
0110                 CF2 is proportional to apparent power (Current Channel B)
0111                 CF2 is proportional to IRMS (Current Channel B)
1000                 CF2 is proportional to IRMS (Current Channel A) + IRMS (Current Channel B)
1001                 CF2 is proportional to active power (Current Channel A) + active power(Current Channel B)
8 CF1DIS 1     0 = CF1 output is enabled, 1 = CF1 output is disabled
9 CF2DIS 1     0 = CF2 output is enabled, 1 = CF2 output is disabled

ALT_OUTPUT Register (Address 0x110)
Bits Bit Name Default Description
[3:0] ZX_ALT 0000 Configuration of ZX pin (Pin 1)
Setting 		ZX Pin Configuration
0000 			ZX detection is output on Pin 1 (default)
0001 			Sag detection is output on Pin 1
0010 			Reserved
0011 			Reserved
0100 			Reserved
0101 			Active power no-load detection (Current Channel A) is output on Pin 1
0110 			Active power no-load detection (Current Channel B) is output on Pin 1
0111 			Reactive power no-load detection (Current Channel A) is output on Pin 1
1000 			Reactive power no-load detection (Current Channel B) is output on Pin 1
1001 			Unlatched waveform sampling signal is output on Pin 1
1010 			IRQ signal is output on Pin 1
1011 			ZX_I detection is output on Pin 1
1100 			REVP detection is output on Pin 1
1101 			Reserved (set to default value)
111x 			Reserved (set to default value)
[7:4] ZXI_ALT 0000 Configuration of ZX_I pin (Pin 21)
Setting 		ZX_I Pin Configuration
0000 			ZX_I detection is output on Pin 21 (default)
0001 			Sag detection is output on Pin 21
0010 			Reserved
0011 			Reserved
0100 			Reserved
0101 			Active power no-load detection (Current Channel A) is output on Pin 21
0110 			Active power no-load detection (Current Channel B) is output on Pin 21
0111 			Reactive power no-load detection (Current Channel A) is output on Pin 21
1000 			Reactive power no-load detection (Current Channel B) is output on Pin 21
1001 			Unlatched waveform sampling signal is output on Pin 21
1010 			IRQ signal is output on Pin 21
1011 			ZX detection is output on Pin 21
1100 			REVP detection is output on Pin 21
1101 			Reserved (set to default value)
111x 			Reserved (set to default value)

[11:8] REVP_ALT 0000 Configuration of REVP pin (Pin 20)
Setting			REVP Pin Configuration
0000 			REVP detection is output on Pin 20 (default)
0001 			Sag detection is output on Pin 20
0010 			Reserved
0011 			Reserved
0100 			Reserved
0101 			Active power no-load detection (Current Channel A) is output on Pin 20
0110 			Active power no-load detection (Current Channel B) is output on Pin 20
0111 			Reactive power no-load detection (Current Channel A) is output on Pin 20
1000 			Reactive power no-load detection (Current Channel B) is output on Pin 20
1001 			Unlatched waveform sampling signal is output on Pin 20
1010 			IRQ signal is output on Pin 20
1011 			ZX detection is output on Pin 20
1100 			ZX_I detection is output on Pin 20
1101 			Reserved (set to default value)
111x 			Reserved (set to default value)

ACCMODE Register (Address 0x201 and Address 0x301)
Bits Bit Name Default Description
[1:0] AWATTACC 00 Current Channel A active energy accumulation mode
Setting Active Energy Accumulation Mode (Current Channel A)
	00 Normal mode
	01 Positive-only accumulation mode
	10 Absolute accumulation mode
	11 Reserved
[3:2] BWATTACC 00 Current Channel B active energy accumulation mode
Setting Active Energy Accumulation Mode (Current Channel B)
	00 Normal mode
	01 Positive-only accumulation mode
	10 Absolute accumulation mode
	11 Reserved
[5:4] AVARACC 00 Current Channel A reactive energy accumulation mode
Setting Reactive Energy Accumulation Mode (Current Channel A)
	00 Normal mode
	01 Antitamper accumulation mode
	10 Absolute accumulation mode
	11 Reserved
[7:6] BVARACC 00 Current Channel B reactive energy accumulation mode
Setting Reactive Energy Accumulation Mode (Current Channel B)
	00 Normal mode
	01 Antitamper accumulation mode
	10 Absolute accumulation mode
	11 Reserved
8 AVAACC 0 0 = Current Channel A apparent energy accumulation is in normal mode, 1 = Current Channel A apparent energy accumulation is based on IRMSA
9 BVAACC 0 0 = Current Channel B apparent energy accumulation is in normal mode, 1 = Current Channel B apparent energy accumulation is based on IRMSB
10 APSIGN_A 0 0 = active power on Current Channel A is positive, 1 = active power on Current Channel A is negative
11 APSIGN_B 0 0 = active power on Current Channel B is positive, 1 = active power on Current Channel B is negative
12 VARSIGN_A 0 0 = reactive power on Current Channel A is positive, 1 = reactive power on Current Channel A is negative
13 VARSIGN_B 0 0 = reactive power on Current Channel B is positive, 1 = reactive power on Current Channel B is negative
[15:14] Reserved 00 Reserved
16 ACTNLOAD_A 0 0 = Current Channel A active energy is out of no-load condition, 1 = Current Channel A active energy is in no-load condition
17 VANLOAD_A 0 0 = Current Channel A apparent energy is out of no-load condition, 1 = Current Channel A apparent energy is in no-load condition
18 VARNLOAD_A 0 0 = Current Channel A reactive energy is out of no-load condition, 1 = Current Channel A reactive energy is in no-load condition
19 ACTNLOAD_B 0 0 = Current Channel B active energy is out of no-load condition, 1 = Current Channel B active energy is in no-load condition
20 VANLOAD_B 0 0 = Current Channel B apparent energy is out of no-load condition, 1 = Current Channel B apparent energy is in no-load condition
21 VARNLOAD_B 0 0 = Current Channel B reactive energy is out of no-load condition, 1 = Current Channel B reactive energy is in no-load condition

'''

# Interrupt Configuration
# Note: For IRQENA Register (Address 0x22C and Address 0x32C)), each binary position of the 16- bit response has the following configuration options
# Bits Bit Name Description
# 0 AEHFA Set to 1 to enable an interrupt when the active energy is half full (Current Channel A)
# 1 VAREHFA Set to 1 to enable an interrupt when the reactive energy is half full (Current Channel A)
# 2 VAEHFA Set to 1 to enable an interrupt when the apparent energy is half full (Current Channel A)
# 3 AEOFA Set to 1 to enable an interrupt when the active energy has overflowed or underflowed (Current Channel A)
# 4 VAREOFA Set to 1 to enable an interrupt when the reactive energy has overflowed or underflowed (Current Channel A)
# 5 VAEOFA Set to 1 to enable an interrupt when the apparent energy has overflowed or underflowed (Current Channel A)
# 6 AP_NOLOADA Set to 1 to enable an interrupt when the active power no-load condition is detected on Current Channel A
# 7 VAR_NOLOADA Set to 1 to enable an interrupt when the reactive power no-load condition is detected on Current Channel A
# 8 VA_NOLOADA Set to 1 to enable an interrupt when the apparent power no-load condition is detected on Current Channel A
# 9 APSIGN_A Set to 1 to enable an interrupt when the sign of active energy has changed (Current Channel A)
# 10 VARSIGN_A Set to 1 to enable an interrupt when the sign of reactive energy has changed (Current Channel A)
# 11 ZXTO_IA Set to 1 to enable an interrupt when the zero crossing has been missing on Current Channel A for the length of time specified in the ZXTOUT register
# 12 ZXIA Set to 1 to enable an interrupt when the current Channel A zero crossing occurs
# 13 OIA Set to 1 to enable an interrupt when the current Channel A peak has exceeded the overcurrent threshold set in the OILVL register
# 14 ZXTO Set to 1 to enable an interrupt when a zero crossing has been missing on the voltage channel for the length of time specified in the ZXTOUT register
# 15 ZXV Set to 1 to enable an interrupt when the voltage channel zero crossing occurs
# 16 OV Set to 1 to enable an interrupt when the voltage peak has exceeded the overvoltage threshold set in the OVLVL register
# 17 WSMP Set to 1 to enable an interrupt when new waveform data is acquired
# 18 CYCEND Set to 1 to enable an interrupt when it is the end of a line cycle accumulation period
# 19 Sag Set to 1 to enable an interrupt when a sag event has occurred
# 20 Reset This interrupt is always enabled and cannot be disabled
# 21 CRC Set to 1 to enable an interrupt when the checksum has changed

# IRQSTATA Register (Address 0x22D and Address 0x32D) and RSTIRQSTATA Register (Address 0x22E and Address 0x32E)
# Bits Bit Name Description
# 0 AEHFA Set to 1 when the active energy register is half full (Current Channel A)
# 1 VAREHFA Set to 1 when the reactive energy register is half full (Current Channel A)
# 2 VAEHFA Set to 1 when the apparent energy register is half full (Current Channel A)
# 3 AEOFA Set to 1 when the active energy register has overflowed or underflowed (Current Channel A)
# 4 VAREOFA Set to 1 when the reactive energy register has overflowed or underflowed (Current Channel A)
# 5 VAEOFA Set to 1 when the apparent energy register has overflowed or underflowed (Current Channel A)
# 6 AP_NOLOADA Set to 1 when the active power no-load condition is detected Current Channel A
# 7 VAR_NOLOADA Set to 1 when the reactive power no-load condition is detected Current Channel A
# 8 VA_NOLOADA Set to 1 when the apparent power no-load condition is detected Current Channel A
# 9 APSIGN_A Set to 1 when the sign of active energy has changed (Current Channel A)
# 10 VARSIGN_A Set to 1 when the sign of reactive energy has changed (Current Channel A)
# 11 ZXTO_IA Set to 1 when a zero crossing has been missing on Current Channel A for the length of time specified in the ZXTOUT register
# 12 ZXIA Set to 1 when a current Channel A zero crossing is detected
# 13 OIA Set to 1 when the current Channel A peak has exceeded the overcurrent threshold set in the OILVL register
# 14 ZXTO Set to 1 when a zero crossing has been missing on the voltage channel for the length of time specified in the ZXTOUT register
# 15 ZXV Set to 1 when the voltage channel zero crossing is detected
# 16 OV Set to 1 when the voltage peak has exceeded the overvoltage threshold set in the OVLVL register
# 17 WSMP Set to 1 when new waveform data is acquired
# 18 CYCEND Set to 1 at the end of a line cycle accumulation period
# 19 Sag Set to 1 when a sag event has occurred
# 20 Reset Set to 1 at the end of a software or hardware reset
# 21 CRC Set to 1 when the checksum has changed

# IRQENB Register (Address 0x22F and Address 0x32F)
# Bits Bit Name Description
# 0 AEHFB Set to 1 to enable an interrupt when the active energy is half full (Current Channel B)
# 1 VAREHFB Set to 1 to enable an interrupt when the reactive energy is half full (Current Channel B)
# 2 VAEHFB Set to 1 to enable an interrupt when the apparent energy is half full (Current Channel B)
# 3 AEOFB Set to 1 to enable an interrupt when the active energy has overflowed or underflowed (Current Channel B)
# 4 VAREOFB Set to 1 to enable an interrupt when the reactive energy has overflowed or underflowed (Current Channel B)
# 5 VAEOFB Set to 1 to enable an interrupt when the apparent energy has overflowed or underflowed (Current Channel B)
# 6 AP_NOLOADB Set to 1 to enable an interrupt when the active power no-load detection on Current Channel B occurs
# 7 VAR_NOLOADB Set to 1 to enable an interrupt when the reactive power no-load detection on Current Channel B occurs
# 8 VA_NOLOADB Set to 1 to enable an interrupt when the apparent power no-load detection on Current Channel B occurs
# 9 APSIGN_B Set to 1 to enable an interrupt when the sign of active energy has changed (Current Channel B)
# 10 VARSIGN_B Set to 1 to enable an interrupt when the sign of reactive energy has changed (Current Channel B)
# 11 ZXTO_IB Set to 1 to enable an interrupt when a zero crossing has been missing on Current Channel B for the length of time specified in the ZXTOUT register
# 12 ZXIB Set to 1 to enable an interrupt when the current Channel B zero crossing occurs
# 13 OIB Set to 1 to enable an interrupt when the current Channel B peak has exceeded the overcurrent threshold set in the OILVL register

# IRQSTATB Register (Address 0x230 and Address 0x330) and RSTIRQSTATB Register (Address 0x231 and Address 0x331)
# Bits Bit Name Description
# 0 AEHFB Set to 1 when the active energy register is half full (Current Channel B)
# 1 VAREHFB Set to 1 when the reactive energy register is half full (Current Channel B)
# 2 VAEHFB Set to 1 when the apparent energy register is half full (Current Channel B)
# 3 AEOFB Set to 1 when the active energy register has overflowed or underflowed (Current Channel B)
# 4 VAREOFB Set to 1 when the reactive energy register has overflowed or underflowed (Current Channel B)
# 5 VAEOFB Set to 1 when the apparent energy register has overflowed or underflowed (Current Channel B)
# 6 AP_NOLOADB Set to 1 when the active power no-load condition is detected on Current Channel B
# 7 VAR_NOLOADB Set to 1 when the reactive power no-load condition is detected on Current Channel B
# 8 VA_NOLOADB Set to 1 when the apparent power no-load condition is detected on Current Channel B
# 9 APSIGN_B Set to 1 when the sign of active energy has changed (Current Channel B)
# 10 VARSIGN_B Set to 1 when the sign of reactive energy has changed (Current Channel B)
# 11 ZXTO_IB Set to 1 when a zero crossing has been missing on Current Channel B for the length of time specified in the ZXTOUT register
# 12 ZXIB Set to 1 when a current Channel B zero crossing is obtained
# 13 OIB Set to 1 when current Channel B peak has exceeded the overcurrent threshold set in the OILVL register

# *******************************************************************************************
import platform

if  platform.linux_distribution()[0] == 'debian':
    import spidev
    import time
    import pigpio



    bus = 0
    device = 0
    spi = spidev.SpiDev()
    pin_gpios = pigpio.pi()
    CS_PIN =25
    READ = 0b10000000
    WRITE = 0b00000000

    # ****************ADE 7953 Library Control Functions**************************************

    # ****************Object Definition*****************
    class ADE7953:

        def __init__(self,frecuency):
            self.frecuency = frecuency
            pin_gpios.write(CS_PIN,1)
    # **************************************************

    # ****************User Program Functions*****************

        def getVersion(self):
            return spiAlgorithm8_read(functionBitVal(Version_8,1), functionBitVal(Version_8,0))  # An example of the address lookup - the spiAlgorithm8_read((functionBitVal(addr,1), functionBitVal(addr,1)) would return the eqivenet to spiAlgorithm8_read(0x07,0x02) when working properly


        def getPowerFactorA(self):
            value=0
            value=spiAlgorithm16_read((functionBitVal(PFA_16,1)),(functionBitVal(PFA_16,0)))
            decimal = decimalize(value, 327.67, 0) # convert to with calibration factors specified
            return abs(decimal)

        def getPowerFactorB(self):
            value=0
            value=spiAlgorithm16_read((functionBitVal(PFB_16,1)),(functionBitVal(PFB_16,0)))
            decimal = decimalize(value, 327.67, 0) # convert to with calibration factors specified
            return abs(decimal)

        def getPhaseCalibA(self):
            value=0
            value=spiAlgorithm16_read((functionBitVal(PHCALA_16,1)),(functionBitVal(PHCALA_16,0)))
            return value

        def getPhaseCalibB(self):
            value=0
            value=spiAlgorithm16_read((functionBitVal(PHCALB_16,1)),(functionBitVal(PHCALB_16,0)))
            return value

        def getPeriod(self):
            value=0
            value=spiAlgorithm16_read((functionBitVal(Period_16,1)),(functionBitVal(Period_16,0)))
            decimal = decimalize(value, 223750, 1/223750) # convert to with calibration factors specified
            return decimal


        def getAPNOLOAD(self):  # use signed for signed registers, and unsigned long for unsigned registers
            value=0  # use signed for signed registers, and unsigned long for unsigned registers
            value=spiAlgorithm32_read((functionBitVal(AP_NOLOAD_32,1)),(functionBitVal(AP_NOLOAD_32,0))) # Call MSB and LSB from the register constant (template for how all functions should be called)
            return value


        def getInstVoltage(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(V_32,1)),(functionBitVal(V_32,0)))
            return value


        def getVrms(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(VRMS_32,1)),(functionBitVal(VRMS_32,0)))
            decimal = decimalize(value, 0x7616, 0) # convert to with calibration factors specified
            return decimal


        def getInstCurrentA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IA_32,1)),(functionBitVal(IA_32,0)))
            return value

        def getInstCurrentB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IB_32,1)),(functionBitVal(IB_32,0)))
            return value

        def getIrmsA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IRMSA_32,1)),(functionBitVal(IRMSA_32,0)))
            decimal = decimalize(value,0xCC,-5.8) # convert to with calibration factors specified
            return decimal

        def getIrmsB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IRMSB_32,1)),(functionBitVal(IRMSB_32,0)))
            decimal = decimalize(value,0xCC,-5.8) # convert to with calibration factors specified
            return decimal


        def getVpeak(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(VPEAK_32,1)),(functionBitVal(VPEAK_32,0)))
            return value


        def getIpeakA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IAPEAK_32,1)),(functionBitVal(IAPEAK_32,0)))
            return value

        def getIpeakB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(IBPEAK_32,1)),(functionBitVal(IBPEAK_32,0)))
            return value

        def getActiveEnergyA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(AENERGYA_32,1)),(functionBitVal(AENERGYA_32,0)))
            return value

        def getActiveEnergyB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(AENERGYB_32,1)),(functionBitVal(AENERGYB_32,0)))
            return value

        def getReactiveEnergyA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(RENERGYA_32,1)),(functionBitVal(RENERGYA_32,0)))
            return value

        def getReactiveEnergyB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(RENERGYB_32,1)),(functionBitVal(RENERGYB_32,0)))
            return value

        def getApparentEnergyA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(APENERGYA_32,1)),(functionBitVal(APENERGYA_32,0)))
            return value

        def getApparentEnergyB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(APENERGYB_32,1)),(functionBitVal(APENERGYB_32,0)))
            return value

        def getInstApparentPowerA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(AVA_32,1)),(functionBitVal(AVA_32,0)))
            decimal = decimalize(value, 1.502, 0) # convert to with calibration factors specified
            return abs(decimal)

        def getInstApparentPowerB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(BVA_32,1)),(functionBitVal(BVA_32,0)))
            decimal = decimalize(value, 1.502, 0) # convert to with calibration factors specified
            return abs(decimal)


        def getInstActivePowerA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(AWATT_32,1)),(functionBitVal(AWATT_32,0)))
            decimal = decimalize(value,1, 0) # convert to with calibration factors specified
            return abs(decimal)

        def getInstActivePowerB(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(BWATT_32,1)),(functionBitVal(BWATT_32,0)))
            decimal = decimalize(value,1, 0) # convert to with calibration factors specified
            return abs(decimal)

        def getInstReactivePowerA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(AVAR_32,1)),(functionBitVal(AVAR_32,0)))
            decimal = decimalize(value, 1.502, 0) # convert to with calibration factors specified
            return decimal

        def getInstReactivePowerA(self):
            value=0
            value=spiAlgorithm32_read((functionBitVal(BVAR_32,1)),(functionBitVal(BVAR_32,0)))
            decimal = decimalize(value, 1.502, 0) # convert to with calibration factors specified
            return decimal
    # ****************Initialization********************
        def initialize(self):

            # ifdef ADE7953_VERBOSE_DEBUG
            # print("ADE7953:initialize function started ")
            # endif

            spi.open(bus,device)
            spi.max_speed_hz = self.frecuency
            spi.mode = 3
            time.sleep(0.1)

            # Write 0x00AD to Register Address 0x00FE. "This unlocks Register 0x120." per datasheet
            pin_gpios.write(CS_PIN,0)
            spi.writebytes([0x00,0xFE,WRITE,0x00,0xAD,0x01,0x20,WRITE,0x00,0x30]) # Pass in MSB of register 0x00FE first.
            pin_gpios.write(CS_PIN,1)
            time.sleep(0.1)
            # ifdef ADE7953_VERBOSE_DEBUG
            # print(" ADE7953:initialize function completed")
            # endif

            # Default Calibrations - Per Datasheet
            # spiAlgorithm16_write((functionBitVal(PHCALA_16,1)),(functionBitVal(PHCALA_16,0)),0x00,0x00)
            # time.sleep(0.1)
            spiAlgorithm32_write((functionBitVal(AP_NOLOAD_32,1)),(functionBitVal(AP_NOLOAD_32,0)),0x00,0x00,0x00,0x01) # Check for ensuring read and write operations are okay
            time.sleep(0.1)
            spiAlgorithm8_write((functionBitVal(LCYCMODE_8,1)),(functionBitVal(LCYCMODE_8,0)),0b01111111) # Enable line cycle accumulation mode for all energies and channels
            time.sleep(0.1)
            spiAlgorithm16_write((functionBitVal(LINECYC_16,1)),(functionBitVal(LINECYC_16,0)),0x00,0x78) # Sets number of half line cycle accumulations to 120
            time.sleep(0.1)


    # **************************************************

    def functionBitVal(addr, byteVal):
        # Returns as integer an address of a specified byte - basically a byte controlled shift register with "byteVal" controlling the byte that is read and returned
        x = ((addr >> (8*byteVal)) & 0xff)
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("functionBitVal function details: ")
        # print("Address input (dec): ",addr)
        # print(" Byte requested (dec): ",byteVal)
        # print(" Returned Value (dec): ", x)
        # print(" Returned Value (HEX): ",hex(x))
        # print("functionBitVal function completed ")
        # endif
        return x

    def spiAlgorithm8_read(MSB, LSB) : # This is the algorithm that reads from a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm8_read function started ")
        # endif
        readval_unsigned = 0  # This variable is the unsigned integer value to compile read bytes into (if needed)

        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,READ])  # Pass in MSB of register to be read first.
        bytes_read = spi.readbytes(2)
        pin_gpios.write(CS_PIN,1)

        one = bytes_read[0]
        two = bytes_read[1]
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm8_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Returned bytes (1(MSB) and 2 - 2nd is for 16-bit return form): ")
        # print(hex(one))
        # print(hex(two))
        # print("spiAlgorithm8_read function completed ")
        # endif

        # Post-read packing and bitshifting operation
        readval_unsigned = one  # Process MSB (nothing much to see here for only one 8 bit value - nothing to shift)
        return readval_unsigned  # uint8_t versus because it is only an 8 bit value, function returns uint8_t.



    def spiAlgorithm16_read(MSB, LSB) : # This is the algorithm that reads from a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm16_read function started ")
        # endif
        readval_unsigned = 0  # This variable is the unsigned integer value to compile read bytes into (if needed)

        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,READ])  # Pass in MSB of register to be read first.
        bytes_read = spi.readbytes(2)
        pin_gpios.write(CS_PIN,1)
        # Read in values sequentially and bitshift for a 32 bit entry
        one = bytes_read[0]
        two = bytes_read[1]
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm16_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Returned bytes (1(MSB) and 2) [HEX]: ")
        # print(hex(one))
        # print(hex(two))
        # print("spiAlgorithm16_read function completed ")
        # endif

        # Post-read packing and bitshifting operation
        readval_unsigned = (one << 8)  # Process MSB  (Bitshift algorithm)
        readval_unsigned = readval_unsigned + two  # Process LSB

        # readval_unsigned = (((uint32_t) one << 8) + ((uint32_t) two))  #Alternate Bitshift algorithm)
        return readval_unsigned




    def spiAlgorithm24_read(MSB, LSB) : # This is the algorithm that reads from a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm24_read function started ")
        # endif
        # readval_signed=0
        readval_unsigned = 0  # This variable is the unsigned integer value to compile read bytes into (if needed)
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,READ])  # Pass in MSB of register to be read first.
        bytes_read= spi.readbytes(3)
        pin_gpios.write(CS_PIN,1)
        # Read in values sequentially and bitshift for a 32 bit entry
        one= bytes_read[0] # MSB Byte 1  (Read in data on dummy write (null MOSI signal))
        two= bytes_read[1]   #  (Read in data on dummy write (null MOSI signal))
        three= bytes_read[2] # LSB Byte 3  (Read in data on dummy write (null MOSI signal))

        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm24_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",MSB)
        # print(" Address Byte 2(LSB]: ",LSB)
        # print(" Returned bytes (1(MSB) to 3]: ")
        # print(hex(one))
        # print(hex(two))
        # print(hex(three))
        # print("spiAlgorithm24_read function completed ")
        # endif

        # Post-read packing and bitshifting operation
        readval_unsigned = ( one << 16)+ (two << 8) + ( three) # Shift algorithm

        # (Alternative Bitshift algorithm)
        #  readval_unsigned =  ((one << 16) & 0x00FF0000)  #process MSB  #(Alternative shift algorithm)
        #  readval_unsigned = readval_unsigned + ((two << 8) & 0X0000FF00)
        #  readval_unsigned = readval_unsigned + (three & 0X000000FF)  #Process LSB

        return readval_unsigned



    def spiAlgorithm32_read(MSB, LSB) : # This is the algorithm that reads from a 32 bit register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.  Caution, some register elements contain information that is only 24 bit with padding on the MSB
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm32_read function started ")
        # endif
        uintreadval_unsigned = 0  # This variable is the unsigned integer value to compile read bytes into (list(hex(if needed)))
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,READ])# Pass in MSB of register to be read first.
        bytes_read = spi.readbytes(4)
        pin_gpios.write(CS_PIN,1)
        # print(bytes_read)

        one = bytes_read[0]
        two = bytes_read[1]
        three = bytes_read[2]
        four = bytes_read[3]
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm32_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ")
        # print(MSB, BIN)
        # print(" Address Byte 2(LSB)[HEX]: ")
        # print(LSB, BIN)
        # print(" Returned bytes (1(MSB) to 4)[HEX]: ")
        # print(one)
        # print(two)
        # print(three)
        # print(four)
        # print("spiAlgorithm32_read function completed ")
        # endif

        # Post-read packing and bitshifting operations
        readval_unsigned = (( one << 24)+ ( two << 16) + ( three << 8) +  four)

        # Alternate Bitshifting approach
        '''   readval_unsigned = (one << 24)  # Process MSB
        # println(readval_unsigned, HEX)
        readval_unsigned = readval_unsigned + (two << 16)
        # println(readval_unsigned, HEX)
        readval_unsigned = readval_unsigned + (three << 8)
        # println(readval_unsigned, HEX)
        readval_unsigned = (readval_unsigned + (four))  # Process LSB
        # println(readval_unsigned, BIN)  '''

        return readval_unsigned



    def spiAlgorithm32_write(MSB, LSB, onemsb, two, three, fourlsb) : # This is the algorithm that writes to a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print(" spiAlgorithm32_write function started ")
        # endif
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,WRITE,onemsb,two,three,fourlsb])  # Pass in MSB of register to be read first.
        pin_gpios.write(CS_PIN,1)

        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm32_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Written bytes (1(MSB) to 4)[HEX]: ",) # MSB to LSB order
        # print(hex(onemsb))
        # print(hex(two))
        # print(hex(three))
        # print(hex(fourlsb))
        # print(" spiAlgorithm32_write function completed ")
        # endif



    def spiAlgorithm24_write(MSB, LSB, onemsb, two, threelsb) : # This is the algorithm that writes to a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print(" spiAlgorithm24_write function started ")
        # endif
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,WRITE,onemsb,two,threelsb])  # Pass in MSB of register to be read first.
        pin_gpios.write(CS_PIN,1)
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm24_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Written bytes (1(MSB) to 3)[HEX]: ")  # MSB to LSB order
        # print(onemsb)
        # print(two)
        # print(threelsb)
        # print(" spiAlgorithm24_write function completed ")
        # endif



    def spiAlgorithm16_write(MSB, LSB, onemsb, twolsb) : # This is the algorithm that writes to a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print(" spiAlgorithm16_write function started ")
        # endif
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,WRITE,onemsb,twolsb])  # Pass in MSB of register to be read first.
        pin_gpios.write(CS_PIN,1)
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm16_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Written bytes (1(MSB) to 2)[HEX]: ")  # MSB to LSB order
        # print(hex(onemsb))
        # print(hex(twolsb))
        # print(" spiAlgorithm16_write function completed ")
        # endif



    def spiAlgorithm8_write(MSB, LSB, onemsb) : # This is the algorithm that writes to a register in the ADE7953. The arguments are the MSB and LSB of the address of the register respectively. The values of the arguments are obtained from the list of functions above.
        # ifdef ADE7953_VERBOSE_DEBUG
        # print(" spiAlgorithm8_write function started ")
        # endif
        pin_gpios.write(CS_PIN,0)
        spi.writebytes([MSB,LSB,WRITE,onemsb])  # Pass in MSB of register to be read first.
        pin_gpios.write(CS_PIN,1)
        # ifdef ADE7953_VERBOSE_DEBUG
        # print("spiAlgorithm8_read function details: ")
        # print("Address Byte 1(MSB)[HEX]: ",hex(MSB))
        # print(" Address Byte 2(LSB)[HEX]: ",hex(LSB))
        # print(" Written bytes (1 of 1)[HEX]: ",hex(onemsb))  # MSB to LSB order
        # print(" spiAlgorithm16_write function completed ")
        # endif



    def decimalize(input, factor, offset): # This function adds a decimal point to the input value and returns it as a float, it also provides linear calibration (y=mx+b) by providing input in the following way as arguments (rawinput, gain, offset)

        # ifdef ADE7953_VERBOSE_DEBUG
        # print("calibration and type conversion function executed ")
    # endif
        return (input/factor + offset)
else:


    # ****************ADE 7953 Library Control Functions**************************************

    # ****************Object Definition*****************
    class ADE7953:

        def __init__(self,frecuency):
            self.frecuency = frecuency
    # **************************************************

    # ****************User Program Functions*****************

        def getVersion(self):
            return

        def getPowerFactorA(self):
            return

        def getPowerFactorB(self):
            return

        def getPhaseCalibA(self):
            return

        def getPhaseCalibB(self):
            return

        def getPeriod(self):
            return


        def getAPNOLOAD(self):  # use signed for signed registers, and unsigned long for unsigned registers
            return


        def getInstVoltage(self):
            return


        def getVrms(self):
            return


        def getInstCurrentA(self):
            return

        def getInstCurrentB(self):
            return

        def getIrmsA(self):
            return

        def getIrmsB(self):
            return


        def getVpeak(self):
            return


        def getIpeakA(self):
            return

        def getIpeakB(self):
            return

        def getActiveEnergyA(self):
            return

        def getActiveEnergyB(self):
            return

        def getReactiveEnergyA(self):
            return

        def getReactiveEnergyB(self):
            return

        def getApparentEnergyA(self):
            return

        def getApparentEnergyB(self):
            return

        def getInstApparentPowerA(self):
            return

        def getInstApparentPowerB(self):
            return


        def getInstActivePowerA(self):
            return

        def getInstActivePowerB(self):
            return

        def getInstReactivePowerA(self):
            return

        def getInstReactivePowerA(self):
            return
    # ****************Initialization********************
        def initialize(self):
            print("Test")
